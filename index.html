<!DOCTYPE html>
<html>
<head>
    <title>AR Grave Grid - Compass Locked</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.150.1/build/three.module.js" } }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 2000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
        }
        #instructions {
            position: fixed; top: 5%; left: 50%; transform: translateX(-50%);
            color: lime; background: rgba(0,0,0,0.5); padding: 10px 20px;
            border-radius: 20px; z-index: 999; text-align: center; font-weight: bold;
            display: none;
        }
        button { padding: 15px 30px; font-size: 18px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 20px;}
    </style>
</head>
<body>

    <div id="overlay">
        <h1>Grave Grid Setup</h1>
        <p>1. Stand near the Tree<br>2. Scan floor until grid appears<br>3. Grid auto-aligns North<br>4. Tap to LOCK</p>
        <button id="startBtn">START AR</button>
    </div>

    <div id="instructions">Scanning Floor...</div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

        let scene, camera, renderer;
        let reticle;             // The helper that sits on the floor
        let ghostGrid;           // The transparent preview
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let isLocked = false;    // Have we dropped it yet?
        let compassHeading = 0;  // Real-world North offset

        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('overlay');
        const instructionUI = document.getElementById('instructions');

        // --- 1. SETUP & EVENTS ---

        startBtn.addEventListener('click', async () => {
            overlay.style.display = 'none';
            instructionUI.style.display = 'block';

            // Request Compass Permission (iOS 13+)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    await DeviceOrientationEvent.requestPermission();
                } catch (e) { console.error(e); }
            }

            // Start listening for North
            window.addEventListener('deviceorientation', handleOrientation, true);
            
            init();
            animate();
        });

        function handleOrientation(event) {
            // Calculate compass heading (0 to 360)
            if (event.webkitCompassHeading) {
                // iOS
                compassHeading = event.webkitCompassHeading;
            } else if (event.alpha) {
                // Android (alpha is usually 0 at initial launch direction, requires calibration)
                compassHeading = 360 - event.alpha; 
            }
        }

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Add the AR Button
            document.body.appendChild(ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.body }
            }));

            // --- 2. CREATE THE RETICLE ---
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // --- 3. CREATE THE GHOST GRID (Attached to Reticle initially) ---
            ghostGrid = new THREE.Group();
            
            // Generate the rings (1-16 Inner, 17-40 Outer)
            // Passing 'true' for isGhost makes them semi-transparent
            generateRing(ghostGrid, 1, 16, 2.0, 0x00ff00, true); 
            generateRing(ghostGrid, 17, 40, 4.0, 0x00ccff, true);

            scene.add(ghostGrid); // We add it to scene, but will move it to reticle position every frame

            // Tap Listener
            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);
        }

        // --- 4. TAP TO LOCK LOGIC ---
        function onSelect() {
            if (reticle.visible && !isLocked) {
                // Lock it!
                isLocked = true;
                
                // Make the grid solid
                ghostGrid.traverse((child) => {
                    if (child.isMesh) {
                        child.material.opacity = 1.0;
                        child.material.transparent = false;
                    }
                    // Show text labels now that we are locked (optional, or keep them visible)
                    if (child.isSprite) {
                        child.visible = true;
                    }
                });

                instructionUI.innerHTML = "GRID LOCKED âœ…";
                instructionUI.style.color = "#00ff00";
                
                // Stop the hit test loop to save battery
                hitTestSourceRequested = false; 
                hitTestSource = null;
                reticle.visible = false;
            }
        }

        // --- 5. GRID GENERATION (Three.js Style) ---
        function generateRing(parent, startNum, endNum, dist, colorHex, isGhost) {
            const total = (endNum - startNum) + 1;
            const perSide = total / 4;
            const step = (dist * 2) / perSide;

            for (let i = 0; i < total; i++) {
                const wrapper = new THREE.Group();
                let x = 0, z = 0;
                const side = Math.floor(i / perSide);
                const progress = (i % perSide) * step - dist;

                if (side === 0) { x = progress; z = -dist; } 
                else if (side === 1) { x = dist; z = progress; } 
                else if (side === 2) { x = -progress; z = dist; } 
                else if (side === 3) { x = -dist; z = -progress; }

                wrapper.position.set(x, 0, z);

                // Circle
                const geometry = new THREE.RingGeometry(0.28, 0.35, 32).rotateX(-Math.PI / 2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: colorHex, 
                    side: THREE.DoubleSide,
                    transparent: isGhost,
                    opacity: isGhost ? 0.5 : 1.0 
                });
                const mesh = new THREE.Mesh(geometry, material);
                wrapper.add(mesh);

                // Number (using CanvasTexture because loading fonts is slow)
                const label = createTextLabel((startNum + i).toString());
                label.position.set(0, 0.05, 0); // slightly up
                // Rotate sprite to lie flat? Sprites always face camera usually. 
                // For floor text in ThreeJS, simpler to use a Mesh with texture.
                label.rotation.x = -Math.PI / 2; 
                wrapper.add(label);

                parent.add(wrapper);
            }
        }

        function createTextLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; 
            canvas.height = 128; 
            const ctx = canvas.getContext('2d');
            
            // Draw number
            ctx.fillStyle = 'rgba(0,0,0,0)'; // transparent bg
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const geometry = new THREE.PlaneGeometry(0.6, 0.6);
            const mesh = new THREE.Mesh(geometry, material);
            
            return mesh;
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                const referenceSpace = renderer.xr.getReferenceSpace();

                // 1. Setup Hit Test if needed
                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((refSpace) => {
                        session.requestHitTestSource({ space: refSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                // 2. Perform Hit Test
                if (hitTestSource && !isLocked) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(referenceSpace);
                        
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                        instructionUI.innerText = "Align Grid with Tree -> Tap to Lock";

                        // 3. Move Ghost Grid to Reticle Position
                        // We decompose the matrix to get position, but we handle rotation manually via compass
                        const position = new THREE.Vector3();
                        const quaternion = new THREE.Quaternion();
                        const scale = new THREE.Vector3();
                        reticle.matrix.decompose(position, quaternion, scale);
                        
                        ghostGrid.position.copy(position);
                        
                        // 4. APPLY COMPASS ROTATION
                        // Convert compass heading to radians. 
                        // Note: This needs tweaking based on device (iOS vs Android)
                        // This logic rotates the grid so 'North' in the grid aligns with real North
                        const angle = THREE.MathUtils.degToRad(-compassHeading); 
                        ghostGrid.rotation.set(0, angle, 0);

                    } else {
                        reticle.visible = false;
                        instructionUI.innerText = "Find the floor...";
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>