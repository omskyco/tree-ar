<!DOCTYPE html>
<html lang="en">
<head>
    <title>Grave Grid - Final North Alignment</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.150.1/build/three.module.js" } }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999; display: flex; flex-direction: column; justify-content: space-between; align-items: center; }
        #instructions { background: rgba(0,0,0,0.7); color: white; padding: 15px; margin-top: 20px; border-radius: 20px; text-align: center; }
        #lockBtn { pointer-events: auto; background: #28a745; color: white; font-size: 18px; padding: 15px 40px; border: none; border-radius: 30px; margin-bottom: 40px; display: none; }
        #debug { position: absolute; top: 10px; right: 10px; color: yellow; font-size: 12px; }
    </style>
</head>
<body>

    <div id="overlay">
        <div id="instructions">Point at Tree Base<br>Wait for White Circle<br>Tap LOCK</div>
        <div id="debug">Compass: ...</div>
        <button id="lockBtn">LOCK GRID HERE</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

        // SETTINGS
        const HEADING_CORRECTION = 0; // Change to 180 if North/South are swapped
        const INNER_DIST = 1.0; 
        const OUTER_DIST = 2.2;

        let scene, camera, renderer, reticle, controller;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let compassHeading = 0;
        let gridLocked = false;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const arBtn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test', 'dom-overlay'], 
                domOverlay: { root: document.getElementById('overlay') } 
            });
            document.body.appendChild(arBtn);

            arBtn.addEventListener('click', () => {
                document.getElementById('lockBtn').style.display = 'block';
                setupCompass();
            });

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            controller = renderer.xr.getController(0);
            scene.add(controller);

            document.getElementById('lockBtn').addEventListener('click', onLockGrid);
        }

        function setupCompass() {
            const handler = (e) => {
                let h = e.webkitCompassHeading || (360 - e.alpha);
                compassHeading = (h + HEADING_CORRECTION) % 360;
                document.getElementById('debug').innerText = `North: ${Math.round(h)}Â°`;
            };
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(res => {
                    if (res === 'granted') window.addEventListener('deviceorientation', handler);
                });
            } else {
                window.addEventListener('deviceorientationabsolute', handler, true);
            }
        }

        function onLockGrid() {
            if (!reticle.visible || gridLocked) return;
            
            const gridGroup = new THREE.Group();
            gridGroup.position.setFromMatrixPosition(reticle.matrix);
            
            // Align to Real North
            gridGroup.rotation.y = -THREE.MathUtils.degToRad(compassHeading);

            // Ring 1 (Inner)
            generateSquareRing(gridGroup, 1, 16, INNER_DIST, 0x00ff00);
            // Ring 2 (Outer)
            generateSquareRing(gridGroup, 17, 40, OUTER_DIST, 0x00ccff);

            scene.add(gridGroup);
            gridLocked = true;
            reticle.visible = false;
            document.getElementById('lockBtn').style.display = 'none';
            document.getElementById('instructions').innerText = "LOCKED TO NORTH";
        }

       function generateSquareRing(parent, start, end, dist, color) {
    for (let num = start; num <= end; num++) {
        let x = 0, z = 0;

        if (start === 1) {
            // INNER RING (1-16) - Mapped to match Bild.jpg perfectly
            const map = {
                16:{x:-0.5, z:-1}, 1:{x:0.5, z:-1}, 2:{x:1.5, z:-1}, 3:{x:2.5, z:-1}, // North
                4:{x:2.5, z:0}, 5:{x:2.5, z:1}, 6:{x:2.5, z:2}, 7:{x:2.5, z:3},       // East
                8:{x:1.5, z:3}, 9:{x:0.5, z:3}, 10:{x:-0.5, z:3}, 11:{x:-1.5, z:3},    // South
                12:{x:-1.5, z:2}, 13:{x:-1.5, z:1}, 14:{x:-1.5, z:0}, 15:{x:-1.5, z:-1} // West
            };
            const p = map[num];
            if(p) { x = p.x * 0.7; z = p.z * 0.7; }
        } else {
            // OUTER RING (17-40) - Corner Overlap Fix
            // North Row: 17 to 20
            if (num >= 17 && num <= 20) { 
                x = (num - 18.5) * 1.1; 
                z = -dist; 
                if (num === 20) x += 0.5; // Push 20 further East
            }
            // East Side: 21 to 25
            else if (num >= 21 && num <= 25) { 
                x = dist + 0.8; 
                z = (num - 23) * 1.1; 
                if (num === 21) z -= 0.3; // Push 21 further North
            }
            // South Side: 26 to 32
            else if (num >= 26 && num <= 32) { 
                x = (29 - num) * 1.1; 
                z = dist + 0.8; 
                if (num === 26) x += 0.3; // Push 26 further East
            }
            // West Side: 33 to 37
            else if (num >= 33 && num <= 37) { 
                x = -(dist + 0.8); 
                z = (35 - num) * 1.1; 
            }
            // North-West Wrap: 38 to 40
            else if (num >= 38 && num <= 40) { 
                x = (num - 41) * 1.1; 
                z = -dist; 
            }
        }

        const marker = createMarker(num, color);
        marker.position.set(x, 0, z);
        parent.add(marker);
    }
}

        function createMarker(num, color) {
            const g = new THREE.Group();
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.25, 0.32, 32).rotateX(-Math.PI/2),
                new THREE.MeshBasicMaterial({ color: color })
            );
            g.add(ring);

            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "white"; ctx.font = "bold 70px Arial"; ctx.textAlign = "center";
            ctx.fillText(num, 64, 85);

            const tex = new THREE.CanvasTexture(canvas);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 0.5).rotateX(-Math.PI/2),
                new THREE.MeshBasicMaterial({ map: tex, transparent: true })
            );
            label.position.y = 0.01;
            g.add(label);
            return g;
        }

        function animate() { renderer.setAnimationLoop(render); }
        function render(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                const refSpace = renderer.xr.getReferenceSpace();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(s => {
                        session.requestHitTestSource({ space: s }).then(src => hitTestSource = src);
                    });
                    hitTestSourceRequested = true;
                }
                if (hitTestSource && !gridLocked) {
                    const results = frame.getHitTestResults(hitTestSource);
                    if (results.length > 0) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(results[0].getPose(refSpace).transform.matrix);
                    } else { reticle.visible = false; }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>